// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: ride_repository_sqlc.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRide = `-- name: CreateRide :one
INSERT INTO
    tb_rides (
        driver_id,
        vehicle_id,
        start_point,
        end_point,
        distance,
        estimated_time_ms,
        co2_emission,
        stop_points,
        cost,
        description,
        img_url,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        ST_SetSRID (ST_MakePoint ($3, $4), 4326),
        ST_SetSRID (ST_MakePoint ($5, $6), 4326),
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        NOW(),
        NOW()
    )
RETURNING
    id,
    driver_id,
    vehicle_id,
    ST_AsText (start_point) AS start_point,
    ST_AsText (end_point) AS end_point,
    distance,
    estimated_time_ms,
    co2_emission,
    ST_AsText (stop_points) AS stop_points,
    cost,
    img_url,
    description,
    created_at,
    updated_at
`

type CreateRideParams struct {
	DriverID        string
	VehicleID       int32
	StMakepoint     interface{}
	StMakepoint_2   interface{}
	StMakepoint_3   interface{}
	StMakepoint_4   interface{}
	Distance        pgtype.Numeric
	EstimatedTimeMs int32
	Co2Emission     pgtype.Numeric
	StopPoints      interface{}
	Cost            pgtype.Numeric
	Description     pgtype.Text
	ImgUrl          pgtype.Text
}

type CreateRideRow struct {
	ID              int32
	DriverID        string
	VehicleID       int32
	StartPoint      interface{}
	EndPoint        interface{}
	Distance        pgtype.Numeric
	EstimatedTimeMs int32
	Co2Emission     pgtype.Numeric
	StopPoints      interface{}
	Cost            pgtype.Numeric
	ImgUrl          pgtype.Text
	Description     pgtype.Text
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) CreateRide(ctx context.Context, arg CreateRideParams) (CreateRideRow, error) {
	row := q.db.QueryRow(ctx, createRide,
		arg.DriverID,
		arg.VehicleID,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StMakepoint_3,
		arg.StMakepoint_4,
		arg.Distance,
		arg.EstimatedTimeMs,
		arg.Co2Emission,
		arg.StopPoints,
		arg.Cost,
		arg.Description,
		arg.ImgUrl,
	)
	var i CreateRideRow
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.VehicleID,
		&i.StartPoint,
		&i.EndPoint,
		&i.Distance,
		&i.EstimatedTimeMs,
		&i.Co2Emission,
		&i.StopPoints,
		&i.Cost,
		&i.ImgUrl,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRide = `-- name: DeleteRide :exec
DELETE FROM tb_rides WHERE id = $1
`

func (q *Queries) DeleteRide(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRide, id)
	return err
}

const findAllRides = `-- name: FindAllRides :many
SELECT
    id,
    driver_id,
    vehicle_id,
    ST_AsText (start_point) AS start_point,
    ST_AsText (end_point) AS end_point,
    distance,
    estimated_time_ms,
    co2_emission,
    ST_AsText (stop_points) AS stop_points,
    cost,
    img_url,
    description,
    created_at,
    updated_at
FROM tb_rides
`

type FindAllRidesRow struct {
	ID              int32
	DriverID        string
	VehicleID       int32
	StartPoint      interface{}
	EndPoint        interface{}
	Distance        pgtype.Numeric
	EstimatedTimeMs int32
	Co2Emission     pgtype.Numeric
	StopPoints      interface{}
	Cost            pgtype.Numeric
	ImgUrl          pgtype.Text
	Description     pgtype.Text
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) FindAllRides(ctx context.Context) ([]FindAllRidesRow, error) {
	rows, err := q.db.Query(ctx, findAllRides)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllRidesRow
	for rows.Next() {
		var i FindAllRidesRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.VehicleID,
			&i.StartPoint,
			&i.EndPoint,
			&i.Distance,
			&i.EstimatedTimeMs,
			&i.Co2Emission,
			&i.StopPoints,
			&i.Cost,
			&i.ImgUrl,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findNearRides = `-- name: FindNearRides :many
WITH
    trajeto AS (
        SELECT unnest($1::point []) AS ponto
    )
SELECT
    id,
    driver_id,
    vehicle_id,
    ST_AsText (start_point) AS start_point,
    ST_AsText (end_point) AS end_point,
    distance,
    estimated_time_ms,
    co2_emission,
    cost,
    ST_AsText (stop_points) AS stop_points,
    description,
    img_url,
    created_at,
    updated_at
FROM tb_rides
WHERE
    EXISTS (
        SELECT 1
        FROM trajeto
        WHERE (
                ST_DWithin (
                    ST_SetSRID (
                        ST_MakePoint (
                            trajeto.ponto[0],
                            trajeto.ponto[1]
                        ),
                        4326
                    )::geography,
                    start_point::geography,
                    $2
                )
                OR ST_DWithin (
                    ST_SetSRID (
                        ST_MakePoint (
                            trajeto.ponto[0],
                            trajeto.ponto[1]
                        ),
                        4326
                    )::geography,
                    end_point::geography,
                    $2
                )
            )
    )
`

type FindNearRidesParams struct {
	Column1   []pgtype.Point
	StDwithin interface{}
}

type FindNearRidesRow struct {
	ID              int32
	DriverID        string
	VehicleID       int32
	StartPoint      interface{}
	EndPoint        interface{}
	Distance        pgtype.Numeric
	EstimatedTimeMs int32
	Co2Emission     pgtype.Numeric
	Cost            pgtype.Numeric
	StopPoints      interface{}
	Description     pgtype.Text
	ImgUrl          pgtype.Text
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) FindNearRides(ctx context.Context, arg FindNearRidesParams) ([]FindNearRidesRow, error) {
	rows, err := q.db.Query(ctx, findNearRides, arg.Column1, arg.StDwithin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindNearRidesRow
	for rows.Next() {
		var i FindNearRidesRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.VehicleID,
			&i.StartPoint,
			&i.EndPoint,
			&i.Distance,
			&i.EstimatedTimeMs,
			&i.Co2Emission,
			&i.Cost,
			&i.StopPoints,
			&i.Description,
			&i.ImgUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRideByID = `-- name: FindRideByID :one
SELECT
    id,
    driver_id,
    vehicle_id,
    ST_AsText (start_point) AS start_point,
    ST_AsText (end_point) AS end_point,
    distance,
    estimated_time_ms,
    co2_emission,
    ST_AsText (stop_points) AS stop_points,
    cost,
    img_url,
    description,
    created_at,
    updated_at
FROM tb_rides
WHERE
    id = $1
`

type FindRideByIDRow struct {
	ID              int32
	DriverID        string
	VehicleID       int32
	StartPoint      interface{}
	EndPoint        interface{}
	Distance        pgtype.Numeric
	EstimatedTimeMs int32
	Co2Emission     pgtype.Numeric
	StopPoints      interface{}
	Cost            pgtype.Numeric
	ImgUrl          pgtype.Text
	Description     pgtype.Text
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) FindRideByID(ctx context.Context, id int32) (FindRideByIDRow, error) {
	row := q.db.QueryRow(ctx, findRideByID, id)
	var i FindRideByIDRow
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.VehicleID,
		&i.StartPoint,
		&i.EndPoint,
		&i.Distance,
		&i.EstimatedTimeMs,
		&i.Co2Emission,
		&i.StopPoints,
		&i.Cost,
		&i.ImgUrl,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRide = `-- name: UpdateRide :one
UPDATE tb_rides
SET
    driver_id = $2,
    vehicle_id = $3,
    start_point = ST_SetSRID (ST_MakePoint ($4, $5), 4326),
    end_point = ST_SetSRID (ST_MakePoint ($6, $7), 4326),
    distance = $8,
    estimated_time_ms = $9,
    co2_emission = $10,
    cost = $11,
    stop_points = $12,
    description = $13,
    img_url = $14,
    updated_at = NOW()
WHERE
    id = $1
RETURNING
    id,
    driver_id,
    vehicle_id,
    ST_AsText (start_point) AS start_point,
    ST_AsText (end_point) AS end_point,
    distance,
    estimated_time_ms,
    co2_emission,
    cost,
    img_url,
    ST_AsText (stop_points) AS stop_points,
    description,
    created_at,
    updated_at
`

type UpdateRideParams struct {
	ID              int32
	DriverID        string
	VehicleID       int32
	StMakepoint     interface{}
	StMakepoint_2   interface{}
	StMakepoint_3   interface{}
	StMakepoint_4   interface{}
	Distance        pgtype.Numeric
	EstimatedTimeMs int32
	Co2Emission     pgtype.Numeric
	Cost            pgtype.Numeric
	StopPoints      interface{}
	Description     pgtype.Text
	ImgUrl          pgtype.Text
}

type UpdateRideRow struct {
	ID              int32
	DriverID        string
	VehicleID       int32
	StartPoint      interface{}
	EndPoint        interface{}
	Distance        pgtype.Numeric
	EstimatedTimeMs int32
	Co2Emission     pgtype.Numeric
	Cost            pgtype.Numeric
	ImgUrl          pgtype.Text
	StopPoints      interface{}
	Description     pgtype.Text
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

func (q *Queries) UpdateRide(ctx context.Context, arg UpdateRideParams) (UpdateRideRow, error) {
	row := q.db.QueryRow(ctx, updateRide,
		arg.ID,
		arg.DriverID,
		arg.VehicleID,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StMakepoint_3,
		arg.StMakepoint_4,
		arg.Distance,
		arg.EstimatedTimeMs,
		arg.Co2Emission,
		arg.Cost,
		arg.StopPoints,
		arg.Description,
		arg.ImgUrl,
	)
	var i UpdateRideRow
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.VehicleID,
		&i.StartPoint,
		&i.EndPoint,
		&i.Distance,
		&i.EstimatedTimeMs,
		&i.Co2Emission,
		&i.Cost,
		&i.ImgUrl,
		&i.StopPoints,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
